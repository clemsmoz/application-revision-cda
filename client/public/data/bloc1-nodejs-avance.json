{
  "id": "bloc1-nodejs-avance",
  "bloc": "bloc1",
  "title": "Node.js - Approfondissement",
  "icon": "üü¢",
  "color": "#339933",
  "description": "Concepts avanc√©s de Node.js : programmation asynchrone, streams, gestion des erreurs, performance, s√©curit√© et d√©ploiement en production.",
  "sections": [
    {
      "id": "async-avance",
      "title": "Programmation Asynchrone Avanc√©e",
      "content": [
        {
          "type": "paragraph",
          "text": "Node.js utilise un mod√®le √©v√©nementiel non-bloquant. La ma√Ætrise de l'asynchrone est essentielle pour des applications performantes."
        },
        {
          "type": "table",
          "headers": [
            "M√©thode",
            "Avantages",
            "Inconv√©nients"
          ],
          "rows": [
            [
              "Callbacks",
              "Simple",
              "Callback hell, gestion d'erreurs complexe"
            ],
            [
              "Promises",
              "Cha√Ænable, .catch()",
              "Verbeux pour plusieurs op√©rations"
            ],
            [
              "Async/Await",
              "Lisible, gestion d'erreurs avec try/catch",
              "N√©cessite des Promises"
            ]
          ]
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Promise.all for ex√©cuter en parall√®le\nconst [users, posts, comments] = await Promise.all([\n  fetchUsers(),\n  fetchPosts(),\n  fetchComments()\n]);\n\n// Promise.race for timeout\nconst result = await Promise.race([\n  fetchData(),\n  new Promise((_, reject) => \n    setTimeout(() => reject(new Error('Timeout')), 5000)\n  )\n]);"
        }
      ]
    },
    {
      "id": "streams",
      "title": "Streams",
      "content": [
        {
          "type": "paragraph",
          "text": "Les streams permettent de traiter des donn√©es volumineuses par morceaux (chunks) sans charger tout en m√©moire."
        },
        {
          "type": "table",
          "headers": [
            "Type de Stream",
            "Description"
          ],
          "rows": [
            [
              "Readable",
              "Lecture de donn√©es (fs.createReadStream)"
            ],
            [
              "Writable",
              "√âcriture de donn√©es (fs.createWriteStream)"
            ],
            [
              "Duplex",
              "Lecture et √©criture (socket TCP)"
            ],
            [
              "Transform",
              "Transformation de donn√©es (compression)"
            ]
          ]
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Copier un fichier avec streams\nconst fs = require('fs');\n\nconst readStream = fs.createReadStream('input.txt');\nconst writeStream = fs.createWriteStream('output.txt');\n\nreadStream.pipe(writeStream);\n\n// Compression avec stream\nconst zlib = require('zlib');\nconst gzip = zlib.createGzip();\n\nfs.createReadStream('file.txt')\n  .pipe(gzip)\n  .pipe(fs.createWriteStream('file.txt.gz'));"
        },
        {
          "type": "alert",
          "level": "tip",
          "text": "Utilisez les streams pour traiter de gros fichiers (logs, CSV, vid√©os) sans saturer la m√©moire."
        }
      ]
    },
    {
      "id": "gestion-erreurs",
      "title": "Gestion des Erreurs",
      "content": [
        {
          "type": "paragraph",
          "text": "Une gestion robuste des erreurs est cruciale pour la stabilit√© d'une application Node.js en production."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Middleware de gestion d'erreurs Express\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: process.env.NODE_ENV === 'production' \n      ? 'Internal Server Error' \n      : err.message\n  });\n});\n\n// Gestion des erreurs non captur√©es\nprocess.on('uncaughtException', (err) => {\n  console.error('Uncaught Exception:', err);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection:', reason);\n  process.exit(1);\n});"
        }
      ]
    },
    {
      "id": "performance",
      "title": "Performance et Optimisation",
      "content": [
        {
          "type": "list",
          "items": [
            "Clustering : Utiliser tous les c≈ìurs CPU avec le module `cluster`",
            "Caching : Redis pour mettre en cache les requ√™tes fr√©quentes",
            "Compression : Compresser les r√©ponses HTTP avec `compression`",
            "Connection pooling : R√©utiliser les connexions DB",
            "Profiling : Identifier les bottlenecks avec `--inspect` et Chrome DevTools",
            "Load balancing : R√©partir la charge avec Nginx ou HAProxy"
          ]
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Clustering\nconst cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  \n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork(); // Red√©marrer\n  });\n} else {\n  // Code du server\n  app.listen(3000);\n}"
        }
      ]
    },
    {
      "id": "securite",
      "title": "S√©curit√©",
      "content": [
        {
          "type": "table",
          "headers": [
            "Vuln√©rabilit√©",
            "Protection"
          ],
          "rows": [
            [
              "Injection",
              "Validation des entr√©es, requ√™tes pr√©par√©es"
            ],
            [
              "XSS",
              "√âchappement des donn√©es, Content Security Policy"
            ],
            [
              "CSRF",
              "Tokens CSRF"
            ],
            [
              "D√©pendances vuln√©rables",
              "npm audit, Snyk"
            ],
            [
              "Secrets expos√©s",
              "Variables d'environnement, .gitignore"
            ],
            [
              "DoS",
              "Rate limiting (express-rate-limit)"
            ]
          ]
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Helmet for s√©curiser les headers HTTP\nconst helmet = require('helmet');\napp.use(helmet());\n\n// Rate limiting\nconst rateLimit = require('express-rate-limit');\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // 100 requ√™tes max\n});\napp.use('/api/', limiter);"
        }
      ]
    }
  ],
  "keyPoints": [
    "Async/Await : syntaxe moderne pour g√©rer l'asynchrone.",
    "Streams : traiter de gros volumes de donn√©es sans saturer la m√©moire.",
    "Gestion d'erreurs : middleware Express + uncaughtException/unhandledRejection.",
    "Performance : clustering, caching (Redis), compression.",
    "S√©curit√© : Helmet, rate limiting, validation des entr√©es, npm audit."
  ],
  "resources": [
    {
      "type": "doc",
      "title": "Node.js Docs",
      "url": "https://nodejs.org/docs/"
    },
    {
      "type": "doc",
      "title": "Express Best Practices",
      "url": "https://expressjs.com/en/advanced/best-practice-security.html"
    }
  ]
}