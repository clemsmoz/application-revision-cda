{
  "id": "bloc1-algorithmique",
  "bloc": "bloc1",
  "title": "Principes Algorithmiques",
  "icon": "üßÆ",
  "color": "#10B981",
  "description": "L'algorithmique est la base de tout programme informatique. Un algorithme est une suite d'instructions logiques qui r√©sout un probl√®me de mani√®re optimale et compr√©hensible.",
  "sections": [
    {
      "id": "intro",
      "title": "Introduction √† l'Algorithmique",
      "content": [
        {
          "type": "paragraph",
          "text": "Un algorithme doit fournir la solution √† un probl√®me de mani√®re **optimale** et **compr√©hensible par tous**. Il s'√©crit sous forme de logigramme (utilisation de symboles) ou en langage naturel simple."
        },
        {
          "type": "definition",
          "term": "Algorithme",
          "definition": "Suite d'instructions logiques ex√©cut√©es les unes apr√®s les autres en fonction des valeurs des variables en entr√©e, produisant un r√©sultat en sortie."
        },
        {
          "type": "alert",
          "level": "info",
          "text": "Un algorithme est **toujours am√©liorable** et **testable**. Il n'existe pas de solution unique √† un probl√®me donn√©."
        }
      ]
    },
    {
      "id": "expressions",
      "title": "Expressions Arithm√©tiques et Logiques",
      "content": [
        {
          "type": "paragraph",
          "text": "Une expression num√©rique est une suite d'op√©rations math√©matiques (addition, soustraction, multiplication, division, etc.). Les r√®gles math√©matiques de base restent appliqu√©es, notamment la **priorit√© des op√©rateurs**."
        },
        {
          "type": "table",
          "headers": [
            "Op√©rateur",
            "Symbole",
            "Priorit√©",
            "Exemple"
          ],
          "rows": [
            [
              "Parenth√®ses",
              "()",
              "1 (plus haute)",
              "(2 + 3) √ó 4 = 20"
            ],
            [
              "Puissance",
              "^",
              "2",
              "2^3 = 8"
            ],
            [
              "Multiplication / Division",
              "√ó /",
              "3",
              "4 √ó 5 / 2 = 10"
            ],
            [
              "Addition / Soustraction",
              "+ -",
              "4 (plus basse)",
              "10 + 5 - 3 = 12"
            ]
          ]
        },
        {
          "type": "alert",
          "level": "warning",
          "text": "**Attention** : En informatique, tout s'√©crit sur une seule ligne. Pensez au typage en sortie et aux priorit√©s des op√©rateurs."
        },
        {
          "type": "subtitle",
          "text": "Expressions Logiques (Bool√©ennes)"
        },
        {
          "type": "paragraph",
          "text": "Les expressions logiques utilisent les op√©rateurs **AND** (ET), **OR** (OU) et **NOT** (N√âGATION) pour effectuer des comparaisons. Le r√©sultat est toujours **Vrai** (True/1) ou **Faux** (False/0)."
        },
        {
          "type": "table",
          "headers": [
            "Op√©rateur",
            "Symbole",
            "Description",
            "Exemple"
          ],
          "rows": [
            [
              "AND (ET)",
              "&&, AND",
              "Vrai si les deux conditions sont vraies",
              "(x > 5) AND (x < 10)"
            ],
            [
              "OR (OU)",
              "||, OR",
              "Vrai si au moins une condition est vraie",
              "(x < 0) OR (x > 100)"
            ],
            [
              "NOT (NON)",
              "!, NOT",
              "Inverse la value logique",
              "NOT (x == 5)"
            ]
          ]
        }
      ]
    },
    {
      "id": "structures-conditionnelles",
      "title": "Structures Conditionnelles",
      "content": [
        {
          "type": "paragraph",
          "text": "Les structures conditionnelles permettent de **choisir une branche d'ex√©cution** en fonction d'une condition logique (Vrai ou Faux)."
        },
        {
          "type": "subtitle",
          "text": "Si / Alors / Sinon (If / Then / Else)"
        },
        {
          "type": "code",
          "language": "pseudo",
          "code": "if condition ALORS\n    // Instructions if la condition est vraie\nelse\n    // Instructions if la condition est fausse\nFIN if"
        },
        {
          "type": "alert",
          "level": "warning",
          "text": "**Attention** : √âviter l'abus d'imbrication de `if/else` pour maintenir la lisibilit√© du code. Pr√©f√©rer les structures √† choix multiples si n√©cessaire."
        },
        {
          "type": "subtitle",
          "text": "Structure √† Choix Multiples (Switch / Select Case)"
        },
        {
          "type": "paragraph",
          "text": "Lorsque trop de `Si / Alors / Sinon` rendent le programme compliqu√©, on utilise une **structure √† choix multiples** qui teste une variable contre plusieurs valeurs possibles."
        },
        {
          "type": "code",
          "language": "pseudo",
          "code": "SELON variable\n    CAS valeur1:\n        // Instructions\n    CAS valeur2:\n        // Instructions\n    D√âFAUT:\n        // Instructions par d√©faut\nFIN SELON"
        }
      ]
    },
    {
      "id": "structures-iteratives",
      "title": "Structures It√©ratives (Boucles)",
      "content": [
        {
          "type": "paragraph",
          "text": "Les boucles permettent de **r√©p√©ter un bloc d'instructions** tant qu'une condition est vraie ou un nombre de fois d√©termin√©."
        },
        {
          "type": "table",
          "headers": [
            "Type de Boucle",
            "Quand l'utiliser",
            "Syntaxe",
            "Risque"
          ],
          "rows": [
            [
              "FOR (Pour)",
              "Nombre d'it√©rations connu √† l'avance",
              "FOR i = 1 TO n",
              "Boucle infinie si mal configur√©e"
            ],
            [
              "WHILE (Tant que) - Pr√©-test√©e",
              "Condition test√©e AVANT l'ex√©cution",
              "WHILE condition DO",
              "Ne s'ex√©cute jamais si condition fausse d√®s le d√©part"
            ],
            [
              "DO WHILE - Post-test√©e",
              "Condition test√©e APR√àS l'ex√©cution (au moins 1 passage)",
              "DO ... WHILE condition",
              "S'ex√©cute au moins une fois"
            ],
            [
              "DO UNTIL (Jusqu'√†)",
              "Arr√™t quand la condition devient vraie",
              "DO ... UNTIL condition",
              "Inverse logique de WHILE"
            ]
          ]
        },
        {
          "type": "alert",
          "level": "danger",
          "text": "**Danger : Boucles infinies** - Toujours v√©rifier que la condition de sortie peut √™tre atteinte. Pensez √† incr√©menter/d√©cr√©menter les compteurs correctement."
        },
        {
          "type": "subtitle",
          "text": "Exemple : Calcul de la somme de 1 √† N"
        },
        {
          "type": "code",
          "language": "pseudo",
          "code": "sum ‚Üê 0\nfor i DE 1 √Ä N do\n    sum ‚Üê sum + i\nFIN for\nAFFICHER sum"
        }
      ]
    },
    {
      "id": "fonctions-procedures",
      "title": "Fonctions et Proc√©dures",
      "content": [
        {
          "type": "paragraph",
          "text": "Les fonctions et proc√©dures permettent de **d√©couper le code en modules r√©utilisables** et de s√©parer les responsabilit√©s."
        },
        {
          "type": "table",
          "headers": [
            "Concept",
            "R√¥le",
            "Retourne une valeur ?",
            "Exemple"
          ],
          "rows": [
            [
              "Proc√©dure (Sub)",
              "Ex√©cute un traitement sans retourner de value",
              "Non",
              "AfficherMessage()"
            ],
            [
              "Fonction",
              "Ex√©cute un traitement et retourne UNE value typ√©e",
              "Oui",
              "CalculerMoyenne() ‚Üí number"
            ]
          ]
        },
        {
          "type": "subtitle",
          "text": "Passage de Param√®tres"
        },
        {
          "type": "table",
          "headers": [
            "Mode",
            "Mot-cl√©",
            "Comportement",
            "Utilisation"
          ],
          "rows": [
            [
              "Par Recopie (Valeur)",
              "ByVal",
              "La value est copi√©e. L'original est prot√©g√©.",
              "Quand on ne veut pas modifier la variable d'origine"
            ],
            [
              "Par R√©f√©rence",
              "ByRef",
              "La variable originale peut √™tre modifi√©e par la fonction.",
              "Quand on veut modifier la variable d'origine (attention aux effets de bord)"
            ]
          ]
        },
        {
          "type": "alert",
          "level": "info",
          "text": "**Bonne pratique** : Pr√©f√©rer les fonctions qui retournent une valeur plut√¥t que les proc√©dures avec passage par r√©f√©rence, pour un code plus lisible et s√ªr."
        }
      ]
    },
    {
      "id": "portee-variables",
      "title": "Port√©e des Variables",
      "content": [
        {
          "type": "paragraph",
          "text": "La **port√©e (scope)** d'une variable d√©termine o√π elle est accessible dans le programme."
        },
        {
          "type": "table",
          "headers": [
            "Type de Port√©e",
            "D√©claration",
            "Accessible",
            "Dur√©e de vie"
          ],
          "rows": [
            [
              "Locale",
              "√Ä l'int√©rieur d'une fonction/proc√©dure",
              "Uniquement dans cette fonction",
              "D√©truite √† la end de la fonction"
            ],
            [
              "Globale (Module)",
              "En dehors de toute fonction",
              "Dans tout le module",
              "Toute l'ex√©cution du programme"
            ],
            [
              "Publique",
              "Avec mot-cl√© Public",
              "Dans tous les modules",
              "Toute l'ex√©cution du programme"
            ]
          ]
        },
        {
          "type": "alert",
          "level": "warning",
          "text": "**Attention** : √âviter l'abus de variables globales qui rendent le code difficile √† d√©boguer et √† maintenir."
        }
      ]
    },
    {
      "id": "tableaux",
      "title": "Tableaux (Arrays)",
      "content": [
        {
          "type": "paragraph",
          "text": "Un tableau permet de stocker **plusieurs valeurs du m√™me type** sous un seul nom de variable, accessibles via un **indice** (index)."
        },
        {
          "type": "subtitle",
          "text": "Tableaux √† Une Dimension"
        },
        {
          "type": "paragraph",
          "text": "Un tableau √† une dimension est une **liste** d'√©l√©ments. L'indice de d√©part est g√©n√©ralement **0** dans la plupart des langages."
        },
        {
          "type": "code",
          "language": "pseudo",
          "code": "// D√©claration d'un array de 10 entiers\nD√âCLARER notes[10] : ENTIER\n\n// Remplissage\nfor i DE 0 √Ä 9 do\n    notes[i] ‚Üê SAISIR()\nFIN for"
        },
        {
          "type": "subtitle",
          "text": "Tableaux Bidimensionnels (Matrices)"
        },
        {
          "type": "paragraph",
          "text": "Un tableau bidimensionnel est une **matrice** (lignes √ó colonnes). Le premier indice repr√©sente la ligne, le second la colonne."
        },
        {
          "type": "code",
          "language": "pseudo",
          "code": "// D√©claration d'une matrice 3√ó3\nD√âCLARER matrice[3][3] : ENTIER\n\n// Parcours avec deux boucles imbriqu√©es\nfor i DE 0 √Ä 2 do\n    for j DE 0 √Ä 2 do\n        matrice[i][j] ‚Üê i * j\n    FIN for\nFIN for"
        },
        {
          "type": "alert",
          "level": "warning",
          "text": "**Attention** : V√©rifier les limites du tableau pour √©viter les erreurs d'acc√®s hors index (index out of bounds)."
        }
      ]
    },
    {
      "id": "chaines-dates",
      "title": "Manipulation des Cha√Ænes et Dates",
      "content": [
        {
          "type": "subtitle",
          "text": "Cha√Ænes de Caract√®res (String)"
        },
        {
          "type": "paragraph",
          "text": "Une cha√Æne de caract√®res est un **tableau de caract√®res**. Tous les langages proposent des fonctions pour les manipuler."
        },
        {
          "type": "table",
          "headers": [
            "Op√©ration",
            "Description",
            "Exemple"
          ],
          "rows": [
            [
              "Longueur",
              "Obtenir le number de caract√®res",
              "LENGTH(\"Hello\") ‚Üí 7"
            ],
            [
              "Extraction",
              "Extraire une sous-cha√Æne",
              "SUBSTRING(\"Hello\", 0, 3) ‚Üí \"Bon\""
            ],
            [
              "Concat√©nation",
              "Assembler deux cha√Ænes",
              "\"Bon\" + \"day\" ‚Üí \"Hello\""
            ],
            [
              "Recherche",
              "Trouver un caract√®re/mot",
              "FIND(\"Hello\", \"day\") ‚Üí 3"
            ]
          ]
        },
        {
          "type": "subtitle",
          "text": "Dates et Heures"
        },
        {
          "type": "paragraph",
          "text": "La manipulation des dates est d√©licate car elle d√©pend du **format de zone** (Europe : JJ/MM/AAAA, USA : MM/JJ/AAAA)."
        },
        {
          "type": "alert",
          "level": "info",
          "text": "**Conseil** : Convertir la date en format nombre (timestamp), la manipuler, puis l'afficher au bon format."
        }
      ]
    },
    {
      "id": "bonnes-pratiques",
      "title": "Bonnes Pratiques en Algorithmique",
      "content": [
        {
          "type": "list",
          "items": [
            "**Diviser pour mieux r√©gner** : D√©couper un probl√®me complexe en sous-probl√®mes plus simples.",
            "**Tester unitairement** : Tester chaque fonction/proc√©dure ind√©pendamment.",
            "**Indentation et formatage** : Respecter une mise en forme claire pour la lisibilit√©.",
            "**Nommer clairement** : Utiliser des noms de variables et fonctions explicites.",
            "**Commenter le code** : Expliquer les parties complexes ou non √©videntes.",
            "**√âviter la duplication** : Factoriser le code r√©p√©titif dans des fonctions.",
            "**G√©rer les erreurs** : Pr√©voir les cas limites et les erreurs possibles."
          ]
        }
      ]
    }
  ],
  "keyPoints": [
    "Un algorithme est une suite d'instructions logiques r√©solvant un probl√®me de mani√®re optimale.",
    "Les structures conditionnelles (if/else, switch) permettent de diriger l'ex√©cution.",
    "Les boucles (for, while, do/while) permettent de r√©p√©ter des instructions.",
    "Les fonctions retournent une valeur, les proc√©dures non.",
    "Le passage par valeur (ByVal) prot√®ge la variable d'origine, le passage par r√©f√©rence (ByRef) la modifie.",
    "Les tableaux permettent de stocker plusieurs valeurs du m√™me type.",
    "Toujours v√©rifier les conditions de sortie des boucles pour √©viter les boucles infinies."
  ],
  "resources": [
    {
      "type": "video",
      "title": "Introduction √† l'algorithmique",
      "url": "#"
    },
    {
      "type": "exercice",
      "title": "Exercices pratiques sur les boucles",
      "url": "#"
    }
  ]
}